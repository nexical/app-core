import fs from 'fs';
import path from 'path';
import yaml from 'yaml';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '..');
const prismaDir = path.join(projectRoot, 'prisma');
const modulesDir = path.join(projectRoot, 'modules');

// Interfaces for our Schema Ontology
interface PrismaField {
  type: string;
  isList?: boolean;
  isRequired?: boolean; // Default true in Prisma, but usually we mark ? for optional
  attributes?: string[]; // e.g. "@id", "@default(autoincrement())"
}

interface PrismaModel {
  db?: boolean; // Default true
  fields: Record<string, PrismaField | string>; // string shorthand for type
  attributes?: string[]; // e.g. "@@index([email])"
}

interface PrismaEnum {
  values: string[];
}

interface PrismaSchema {
  datasource?: Record<string, unknown>;
  generator?: Record<string, Record<string, unknown>>;
  models?: Record<string, PrismaModel>;
  enums?: Record<string, PrismaEnum>;
}

// Helper to deep merge schemas
function mergeSchemas(target: PrismaSchema, source: PrismaSchema) {
  if (source.datasource) target.datasource = { ...target.datasource, ...source.datasource };
  if (source.generator) target.generator = { ...target.generator, ...source.generator };

  if (source.models) {
    target.models = target.models || {};
    for (const [name, model] of Object.entries(source.models)) {
      // Skip Virtual Models (DTOs)
      if (model.db === false) continue;

      if (!target.models[name]) {
        target.models[name] = model;
      } else {
        // Merge fields
        target.models[name].fields = { ...target.models[name].fields, ...model.fields };
        // Merge attributes (arrays) with deduping
        if (model.attributes) {
          const existing = new Set(target.models[name].attributes || []);
          for (const attr of model.attributes) {
            if (!existing.has(attr)) {
              existing.add(attr);
            }
          }
          target.models[name].attributes = Array.from(existing);
        }
      }
    }
  }

  if (source.enums) {
    target.enums = target.enums || {};
    for (const [name, enumDef] of Object.entries(source.enums)) {
      if (!target.enums[name]) {
        target.enums[name] = enumDef;
      } else {
        // Append values
        const existing = new Set(target.enums[name].values);
        for (const val of enumDef.values) {
          if (!existing.has(val)) {
            target.enums[name].values.push(val);
          }
        }
      }
    }
  }
}

function parseModelField(name: string, def: PrismaField | string): string {
  if (typeof def === 'string') {
    // Shorthand: "String?" or "User @relation(...)"
    return `  ${name} ${def}`;
  }

  let typeStr = def.type;
  if (def.isList) typeStr += '[]';
  if (def.isRequired === false) typeStr += '?'; // Explicit optional

  const attrs = def.attributes ? ` ${def.attributes.join(' ')}` : '';
  return `  ${name} ${typeStr}${attrs}`;
}

function generatePrismaFile(schema: PrismaSchema): string {
  let output = '// STRONGLY TYPED PRISMA SCHEMA - GENERATED BY scripts/generate-prisma.ts\n\n';

  // Datasource
  if (schema.datasource) {
    output += 'datasource db {\n';
    for (const [key, val] of Object.entries(schema.datasource)) {
      let valueStr = val;
      if (typeof val === 'string' && !val.startsWith('env(') && !val.startsWith('"')) {
        valueStr = `"${val}"`;
      }
      output += `  ${key} = ${valueStr}\n`;
    }
    output += '}\n\n';
  }

  // Generators
  if (schema.generator) {
    for (const [name, config] of Object.entries(schema.generator)) {
      output += `generator ${name} {\n`;
      for (const [key, val] of Object.entries(config)) {
        let valueStr = val;
        if (Array.isArray(val)) {
          // Ensure we don't double quote if YAML already has them
          valueStr = `[${val.map((v) => (v.startsWith('"') ? v : `"${v}"`)).join(', ')}]`;
        } else if (typeof val === 'string' && !val.startsWith('env(') && !val.startsWith('"')) {
          // Always quote strings unless they look like env() or are already quoted
          valueStr = `"${val}"`;
        }
        output += `  ${key} = ${valueStr}\n`;
      }
      output += '}\n\n';
    }
  }

  // Enums
  if (schema.enums) {
    for (const [name, def] of Object.entries(schema.enums)) {
      output += `enum ${name} {\n`;
      for (const val of def.values) {
        output += `  ${val}\n`;
      }
      output += '}\n\n';
    }
  }

  // Models
  if (schema.models) {
    for (const [name, def] of Object.entries(schema.models)) {
      output += `model ${name} {\n`;
      for (const [fieldName, fieldDef] of Object.entries(def.fields)) {
        output += parseModelField(fieldName, fieldDef) + '\n';
      }
      if (def.attributes) {
        for (const attr of def.attributes) {
          output += `  ${attr}\n`;
        }
      }
      output += '}\n\n';
    }
  }

  return output;
}

// Main execution
async function main() {
  const combinedSchema: PrismaSchema = {};

  // 1. Read Core
  const coreYamlPath = path.join(prismaDir, 'models.yaml');
  if (fs.existsSync(coreYamlPath)) {
    console.info(`Loading core schema: ${coreYamlPath}`);
    const content = fs.readFileSync(coreYamlPath, 'utf8');
    const parsed = yaml.parse(content);
    mergeSchemas(combinedSchema, parsed);
  }

  // 2. Read Modules
  if (fs.existsSync(modulesDir)) {
    const modules = fs.readdirSync(modulesDir);
    for (const mod of modules) {
      const modYamlPath = path.join(modulesDir, mod, 'models.yaml');
      if (fs.existsSync(modYamlPath)) {
        console.info(`Loading module schema: ${mod} (${modYamlPath})`);
        const content = fs.readFileSync(modYamlPath, 'utf8');
        const parsed = yaml.parse(content);
        mergeSchemas(combinedSchema, parsed);
      }
    }
  }

  // 3. Generate
  const psl = generatePrismaFile(combinedSchema);
  const outputPath = path.join(prismaDir, 'schema.prisma');
  fs.writeFileSync(outputPath, psl);
  console.info(`Generated ${outputPath}`);
}

main().catch(console.error);
